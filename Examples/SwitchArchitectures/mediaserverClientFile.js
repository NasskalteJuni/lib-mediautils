// like any 'normal' web client, handle connections with a connection-manager object.
// just pass in the (autogenerated) signaller, which wraps the Tunnel-Objects methods in Websocket-like methods
const connections = new MediaUtilities.ConnectionManager({isYielding: true, verbose: true, signaller});

// listen for received streams, then, forward the received streams to everyone else
connections.addEventListener('streamadded', (stream, user) => {
    connections.addMedia(stream);
});
// when a stream ends / is removed, stop forwarding it
connections.addEventListener('streamremoved', (stream, user) => {
    connections.removeMedia(stream)
});

Tunnel.onImport('architecture', (type) => {
    console.log('architecture was switched to', type);
    if(type === 'mesh'){
        connections.removeMedia();
    }
});