// like any 'normal' web client, handle connections with a connection-manager object.
// just pass in the (autogenerated) signaller, which wraps the Tunnel-Objects methods in Websocket-like methods
const signaler = MediaUtilities.wrapTunnelAsSignaler(Tunnel);
const connections = new MediaUtilities.ConnectionManager({name: '@mcu', isYielding: true, verbose: false, signaler});
const videoMixer = new MediaUtilities.VideoMixer({width: 640, height: 480});
const audioMixers = {};
videoMixer.addConfig(new MediaUtilities.VideoMixingConfigurations.Line(0, true), 'line');
videoMixer.addConfig(new MediaUtilities.VideoMixingConfigurations.Grid(1, ids => [4,6,8,9,10].indexOf(ids.length) >= 0), 'grid');


// listen for received streams, then, forward the received streams to everyone else
connections.addEventListener('streamadded', (stream, user) => {
    console.log('stream added for', user, stream);
    videoMixer.addStream(stream, user+'-'+stream.id);
    Object.keys(audioMixers).filter(key => user !== key).forEach(key => audioMixers[key].addStream(stream,user+'-'+stream.id));
});
// when a stream ends / is removed, stop forwarding it
connections.addEventListener('streamremoved', (stream, user) => {
    console.log('stream removed for', user, stream);
    videoMixer.removeStream(user+'-'+stream.id);
    Object.keys(audioMixers).filter(key => user !== key).forEach(key => audioMixers[key].removeStream(user+'-'+stream.id));
});
// every user has his own audio mixer
connections.addEventListener('userconnected', (user) => {
    audioMixers[user] = new MediaUtilities.AudioMixer();
    connections.get(user).addMedia(new MediaStream([audioMixers[user].outputTrack, videoMixer.outputTrack]));
});
// which will be removed when the user disconnects
connections.addEventListener('userdisconnected', (user) => {
    delete audioMixers[user];
});